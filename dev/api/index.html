<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · Graphons.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://SDS-EPFL.github.io/Graphons.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Graphons.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Graphon-Types"><span>Graphon Types</span></a></li><li><a class="tocitem" href="#Sampling-Functions"><span>Sampling Functions</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><a class="tocitem" href="../tutorials/01_simple_graphon/">Getting Started with Graphons</a></li><li><a class="tocitem" href="../tutorials/03_block_models/">Stochastic Block Models</a></li><li><a class="tocitem" href="../tutorials/02_multiplex_networks/">Multiplex Networks</a></li><li><a class="tocitem" href="../tutorials/04_custom_distributions/">Custom Distributions</a></li></ul></li><li><span class="tocitem">Design</span><ul><li><a class="tocitem" href="../graphs_type/">Graph representation</a></li><li><a class="tocitem" href="../custom_distributions/">Custom Distribution Types</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SDS-EPFL/Graphons.jl/blob/main/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Graphon-Types"><a class="docs-heading-anchor" href="#Graphon-Types">Graphon Types</a><a id="Graphon-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Graphon-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Graphons.AbstractGraphon" href="#Graphons.AbstractGraphon"><code>Graphons.AbstractGraphon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGraphon{T,M}</code></pre><p>Abstract base type for all graphon models.</p><p><strong>Type Parameters</strong></p><ul><li><code>T</code>: The edge type (e.g., <code>Bool</code> for simple graphs, <code>Float64</code> for weighted graphs, <code>SizedVector{2,Bool}</code> for multiplex networks)</li><li><code>M</code>: The matrix type for sampled graphs (e.g., <code>BitMatrix</code>, <code>Matrix{T}</code>, <code>SparseMatrixCSC{T,Int}</code>, <code>GBMatrix{T}</code>)</li></ul><p><strong>Edge Types</strong></p><ul><li><code>Bool</code>: Simple (unweighted) graphs</li><li><code>&lt;:Real</code>: Weighted graphs with numeric edge weights</li><li><code>&lt;:AbstractVector{Bool}</code>: Multiplex networks with multiple edge types</li></ul><p><strong>Matrix Types</strong></p><ul><li><code>BitMatrix</code> or <code>Matrix{Bool}</code>: Dense representation for simple graphs</li><li><code>Matrix{T}</code>: Dense representation for weighted/decorated graphs</li><li><code>SparseMatrixCSC{T,Int}</code>: Sparse representation for low-density graphs</li><li><code>GBMatrix{T}</code>: GraphBLAS representation (requires SuiteSparseGraphBLAS extension)</li></ul><p>All graphon types must:</p><ol><li>Be callable: <code>graphon(x, y)</code> returns probability or distribution at positions <code>x, y ∈ [0,1]</code></li><li>Support <code>make_empty_graph(M, n)</code> for creating empty adjacency matrices</li><li>Implement sampling through <code>_rand!</code> method</li></ol><p><strong>Subtypes</strong></p><ul><li><a href="#Graphons.SimpleContinuousGraphon"><code>SimpleContinuousGraphon</code></a>: Continuous function-based graphons</li><li><a href="#Graphons.SBM"><code>SBM</code></a>: Stochastic block models</li><li><a href="#Graphons.DecoratedGraphon"><code>DecoratedGraphon</code></a>: Graphons with distribution-valued edges</li><li><a href="#Graphons.DecoratedSBM"><code>DecoratedSBM</code></a>: Block models with distribution-valued edges</li></ul><p><strong>See Also</strong></p><ul><li><a href="#Base.rand-Tuple{AbstractRNG, Graphons.AbstractGraphon, Int64}"><code>rand</code></a>, <a href="#Graphons.sample_graph"><code>sample_graph</code></a>: Sampling functions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SDS-EPFL/Graphons.jl/blob/041c7921853d8de97ef275a7457e7e83dacba9d7/src/Graphons.jl#L11-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphons.SimpleGraphon" href="#Graphons.SimpleGraphon"><code>Graphons.SimpleGraphon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleGraphon{M}</code></pre><p>Type alias for graphons representing simple (unweighted) graphs with Boolean edges.</p><p>Equivalent to <code>AbstractGraphon{Bool,M}</code> where <code>M</code> is a matrix type storing Boolean values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SDS-EPFL/Graphons.jl/blob/041c7921853d8de97ef275a7457e7e83dacba9d7/src/Graphons.jl#L49-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphons.WeightedGraphon" href="#Graphons.WeightedGraphon"><code>Graphons.WeightedGraphon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WeightedGraphon{M}</code></pre><p>Type alias for graphons representing weighted graphs with Float64 edges.</p><p>Equivalent to <code>AbstractGraphon{Float64,M}</code> where <code>M</code> is a matrix type storing Float64 values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SDS-EPFL/Graphons.jl/blob/041c7921853d8de97ef275a7457e7e83dacba9d7/src/Graphons.jl#L58-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphons.SimpleContinuousGraphon" href="#Graphons.SimpleContinuousGraphon"><code>Graphons.SimpleContinuousGraphon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleContinuousGraphon{M,F} &lt;: SimpleGraphon{M}</code></pre><p>A continuous graphon represented by a function <code>f(x, y)</code> that returns the probability of an edge between nodes at latent positions <code>x</code> and <code>y</code> in [0,1].</p><p><strong>Type Parameters</strong></p><ul><li><code>M</code>: The matrix type used to represent sampled graphs (e.g., <code>BitMatrix</code>, <code>SparseMatrixCSC{Bool,Int}</code>)</li><li><code>F</code>: The type of the graphon function</li></ul><p><strong>Fields</strong></p><ul><li><code>f::F</code>: A callable function <code>f(x, y) -&gt; Float64</code> where x, y ∈ [0,1] and the return value is in [0,1]</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SimpleContinuousGraphon(f, M=BitMatrix)</code></pre><p>Create a continuous graphon from function <code>f</code> with matrix type <code>M</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Constant probability graphon
g = SimpleContinuousGraphon((x, y) -&gt; 0.5)

# Distance-based graphon
g = SimpleContinuousGraphon((x, y) -&gt; exp(-abs(x - y)))

# Sparse matrix representation
g = SimpleContinuousGraphon((x, y) -&gt; 0.1, SparseMatrixCSC{Bool,Int})</code></pre><p><strong>See Also</strong></p><ul><li><a href="#Graphons.SBM"><code>SBM</code></a>: Discrete stochastic block model</li><li><a href="#Graphons.empirical_graphon"><code>empirical_graphon</code></a>: Discretize a continuous graphon</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SDS-EPFL/Graphons.jl/blob/041c7921853d8de97ef275a7457e7e83dacba9d7/src/simple_graphon.jl#L3-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphons.SBM" href="#Graphons.SBM"><code>Graphons.SBM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SBM{P,S,S2} &lt;: AbstractGraphon{Bool,BitMatrix}</code></pre><p>A Stochastic Block Model (SBM) is a discrete graphon with <code>K</code> blocks where edge probabilities depend only on the block membership of nodes.</p><p><strong>Fields</strong></p><ul><li><code>θ::P</code>: K×K matrix of edge probabilities between blocks, where θ[i,j] is the probability of an edge between block i and j</li><li><code>size::S</code>: Vector of block sizes (must sum to 1), representing the proportion of nodes in each block</li><li><code>cumsize::S2</code>: Cumulative sum of block sizes for efficient block assignment</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SBM(θ, sizes)</code></pre><p>Create a stochastic block model with edge probability matrix <code>θ</code> and block sizes <code>sizes</code>.</p><p><strong>Arguments</strong></p><ul><li><code>θ</code>: K×K matrix where each entry is in [0,1]</li><li><code>sizes</code>: Vector of K positive values that sum to 1</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Two-block assortative model
θ = [0.8 0.1; 0.1 0.8]
sizes = [0.5, 0.5]
sbm = SBM(θ, sizes)

# Three-block model with unequal sizes
θ = [0.9 0.1 0.2; 0.1 0.8 0.1; 0.2 0.1 0.7]
sizes = [0.3, 0.5, 0.2]
sbm = SBM(θ, sizes)</code></pre><p><strong>See Also</strong></p><ul><li><a href="#Graphons.SimpleContinuousGraphon"><code>SimpleContinuousGraphon</code></a>: Continuous graphon representation</li><li><a href="#Graphons.empirical_graphon"><code>empirical_graphon</code></a>: Convert continuous graphon to SBM</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SDS-EPFL/Graphons.jl/blob/041c7921853d8de97ef275a7457e7e83dacba9d7/src/simple_graphon.jl#L50-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphons.DecoratedGraphon" href="#Graphons.DecoratedGraphon"><code>Graphons.DecoratedGraphon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DecoratedGraphon{T,M,F,D} &lt;: AbstractGraphon{T,M}</code></pre><p>A decorated graphon where edges have rich attributes drawn from distributions. Instead of returning edge probabilities, the graphon function returns a distribution from which edge values are sampled.</p><p><strong>Type Parameters</strong></p><ul><li><code>T</code>: The type of edge values (inferred from the distribution)</li><li><code>M</code>: The matrix type for sampled graphs</li><li><code>F</code>: The type of the graphon function</li><li><code>D</code>: The type of distributions returned by the function</li></ul><p><strong>Fields</strong></p><ul><li><code>f::F</code>: A callable function <code>f(x, y) -&gt; Distribution</code> where x, y ∈ [0,1]</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">DecoratedGraphon(f)
DecoratedGraphon(f, M)</code></pre><p>Create a decorated graphon from function <code>f</code>. The edge type is automatically inferred by evaluating <code>f(0.1, 0.2)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Distributions

# Edges are normal random variables
g = DecoratedGraphon((x, y) -&gt; Normal(x + y, 0.1))

# Edges are Poisson counts
g = DecoratedGraphon((x, y) -&gt; Poisson(10 * x * y))

# With custom matrix type
g = DecoratedGraphon((x, y) -&gt; Normal(0, 1), Matrix{Float64})</code></pre><p><strong>See Also</strong></p><ul><li><a href="#Graphons.DecoratedSBM"><code>DecoratedSBM</code></a>: Block model with distributions</li><li><a href="#Graphons.SimpleContinuousGraphon"><code>SimpleContinuousGraphon</code></a>: Simple graphon with probabilities</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SDS-EPFL/Graphons.jl/blob/041c7921853d8de97ef275a7457e7e83dacba9d7/src/decorated_graphon.jl#L10-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphons.DecoratedSBM" href="#Graphons.DecoratedSBM"><code>Graphons.DecoratedSBM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DecoratedSBM{D,M,P,S,S2} &lt;: AbstractGraphon{eltype(M),M}</code></pre><p>A Stochastic Block Model where edges have rich attributes drawn from distributions. Each block pair (i,j) has an associated distribution from which edge values are sampled.</p><p><strong>Fields</strong></p><ul><li><code>θ::P</code>: K×K matrix of distributions, where θ[i,j] is the distribution for edges between block i and j</li><li><code>size::S</code>: Vector of block sizes (must sum to 1)</li><li><code>cumsize::S2</code>: Cumulative sum of block sizes</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">DecoratedSBM(θ, sizes, M=Matrix{...})</code></pre><p>Create a decorated SBM with distribution matrix <code>θ</code> and block sizes <code>sizes</code>.</p><p><strong>Arguments</strong></p><ul><li><code>θ</code>: K×K matrix of Distribution objects</li><li><code>sizes</code>: Vector of K positive values that sum to 1</li><li><code>M</code>: (Optional) Matrix type for sampled graphs</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Distributions

# Two-block model with Normal edges
θ = [Normal(1.0, 0.1) Normal(0.0, 0.1);
     Normal(0.0, 0.1) Normal(1.0, 0.1)]
sizes = [0.5, 0.5]
dsbm = DecoratedSBM(θ, sizes)

# Poisson-weighted edges
θ = [Poisson(10) Poisson(2); Poisson(2) Poisson(10)]
dsbm = DecoratedSBM(θ, sizes)</code></pre><p><strong>See Also</strong></p><ul><li><a href="#Graphons.DecoratedGraphon"><code>DecoratedGraphon</code></a>: Continuous decorated graphon</li><li><a href="#Graphons.SBM"><code>SBM</code></a>: Simple block model with probabilities</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SDS-EPFL/Graphons.jl/blob/041c7921853d8de97ef275a7457e7e83dacba9d7/src/decorated_graphon.jl#L73-L112">source</a></section></article><h2 id="Sampling-Functions"><a class="docs-heading-anchor" href="#Sampling-Functions">Sampling Functions</a><a id="Sampling-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{AbstractRNG, Graphons.AbstractGraphon, Int64}" href="#Base.rand-Tuple{AbstractRNG, Graphons.AbstractGraphon, Int64}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand([rng::AbstractRNG], graphon::AbstractGraphon{T,M}, n::Int) -&gt; M</code></pre><p>Generate a random graph from a graphon with <code>n</code> nodes.</p><p>Latent positions for each node are drawn uniformly at random from [0,1], and edges are sampled according to the graphon. For simple graphons, edges are present with probability <code>f(ξᵢ, ξⱼ)</code>. For decorated graphons, edge weights are sampled from the distribution <code>f(ξᵢ, ξⱼ)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: Random number generator (optional, defaults to <code>Random.default_rng()</code>)</li><li><code>graphon</code>: A graphon model (e.g., <a href="#Graphons.SimpleContinuousGraphon"><code>SimpleContinuousGraphon</code></a>, <a href="#Graphons.SBM"><code>SBM</code></a>, <a href="#Graphons.DecoratedGraphon"><code>DecoratedGraphon</code></a>)</li><li><code>n</code>: Number of nodes in the graph</li></ul><p><strong>Returns</strong></p><p>An adjacency matrix of type <code>M</code> (determined by the graphon) with:</p><ul><li>Symmetric structure: <code>A[i,j] == A[j,i]</code></li><li>No self-loops: <code>A[i,i] == 0</code> for all i</li><li>Edge type <code>T</code> (Bool for simple graphs, Float64 for weighted, etc.)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Simple random graph
g = SimpleContinuousGraphon((x, y) -&gt; 0.3)
A = rand(g, 100)  # 100-node graph with 30% edge probability

# Reproducible sampling
using Random
rng = MersenneTwister(42)
A = rand(rng, g, 100)

# Stochastic block model
sbm = SBM([0.8 0.1; 0.1 0.8], [0.5, 0.5])
A = rand(sbm, 200)

# Decorated graphon with weighted edges
using Distributions
dg = DecoratedGraphon((x, y) -&gt; Normal(x + y, 0.1))
W = rand(dg, 50)  # Returns Matrix{Float64}</code></pre><p><strong>See Also</strong></p><ul><li><a href="#Graphons.sample_graph"><code>sample_graph</code></a>: Sample with fixed latent positions</li><li><a href="#Graphons.SimpleContinuousGraphon"><code>SimpleContinuousGraphon</code></a>, <a href="#Graphons.SBM"><code>SBM</code></a>, <a href="#Graphons.DecoratedGraphon"><code>DecoratedGraphon</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SDS-EPFL/Graphons.jl/blob/041c7921853d8de97ef275a7457e7e83dacba9d7/src/sampling.jl#L6-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphons.sample_graph" href="#Graphons.sample_graph"><code>Graphons.sample_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample_graph([rng::AbstractRNG], graphon::AbstractGraphon, n::Int) -&gt; M
sample_graph([rng::AbstractRNG], graphon::AbstractGraphon, ξs::AbstractVector) -&gt; M</code></pre><p>Generate a graph from a graphon with deterministic or specified latent positions.</p><p>This function provides more control than <a href="#Base.rand-Tuple{AbstractRNG, Graphons.AbstractGraphon, Int64}"><code>rand</code></a> by allowing you to:</p><ol><li>Use evenly-spaced latent positions <code>ξ = [0, 1/(n-1), 2/(n-1), ..., 1]</code></li><li>Specify custom latent positions for each node</li></ol><p>Graphs sampled with the same latent positions will have the same expected structure, making this useful for reproducibility and controlled experiments.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: Random number generator (optional)</li><li><code>graphon</code>: A graphon model</li><li><code>n</code>: Number of nodes (latents will be evenly spaced on [0,1])</li><li><code>ξs</code>: Vector of latent positions in [0,1], one per node</li></ul><p><strong>Returns</strong></p><p>An adjacency matrix of type <code>M</code> with symmetric structure and no self-loops.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Evenly-spaced latents
g = SimpleContinuousGraphon((x, y) -&gt; x * y)
A = sample_graph(g, 10)  # Uses ξ = [0, 0.111..., 0.222..., ..., 1]

# Custom latent positions
ξs = [0.1, 0.2, 0.5, 0.9]
A = sample_graph(g, ξs)

# Reproducible with same latents
using Random
rng = MersenneTwister(42)
A1 = sample_graph(rng, g, ξs)
rng = MersenneTwister(42)
A2 = sample_graph(rng, g, ξs)
# A1 and A2 will be identical

# Compare random vs deterministic latents
A_random = rand(g, 100)        # Random latents
A_fixed = sample_graph(g, 100) # Evenly-spaced latents</code></pre><p><strong>See Also</strong></p><ul><li><a href="#Base.rand-Tuple{AbstractRNG, Graphons.AbstractGraphon, Int64}"><code>rand</code></a>: Sample with random latent positions</li><li><a href="#Graphons.SimpleContinuousGraphon"><code>SimpleContinuousGraphon</code></a>, <a href="#Graphons.SBM"><code>SBM</code></a>, <a href="#Graphons.DecoratedGraphon"><code>DecoratedGraphon</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SDS-EPFL/Graphons.jl/blob/041c7921853d8de97ef275a7457e7e83dacba9d7/src/sampling.jl#L97-L145">source</a></section></article><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Graphons.empirical_graphon" href="#Graphons.empirical_graphon"><code>Graphons.empirical_graphon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">empirical_graphon(f::SimpleContinuousGraphon, k::Int) -&gt; SBM</code></pre><p>Discretize a continuous graphon into a Stochastic Block Model with <code>k</code> blocks by evaluating the graphon at a uniform grid of points.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: A continuous graphon</li><li><code>k</code>: Number of blocks for discretization</li></ul><p><strong>Returns</strong></p><p>An <a href="#Graphons.SBM"><code>SBM</code></a> with <code>k</code> blocks approximating the continuous graphon.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create continuous graphon
f = SimpleContinuousGraphon((x, y) -&gt; min(x, y))

# Discretize into 10-block SBM
sbm = empirical_graphon(f, 10)</code></pre><p><strong>See Also</strong></p><ul><li><a href="#Graphons.SimpleContinuousGraphon"><code>SimpleContinuousGraphon</code></a>: Continuous graphon type</li><li><a href="#Graphons.SBM"><code>SBM</code></a>: Stochastic block model type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SDS-EPFL/Graphons.jl/blob/041c7921853d8de97ef275a7457e7e83dacba9d7/src/simple_graphon.jl#L108-L133">source</a></section><section><div><pre><code class="language-julia hljs">empirical_graphon(f::DecoratedGraphon, k::Int) -&gt; DecoratedSBM</code></pre><p>Discretize a continuous decorated graphon into a block model with <code>k</code> blocks by evaluating the graphon at a uniform grid of points.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: A decorated graphon</li><li><code>k</code>: Number of blocks for discretization</li></ul><p><strong>Returns</strong></p><p>A <a href="#Graphons.DecoratedSBM"><code>DecoratedSBM</code></a> with <code>k</code> blocks approximating the continuous graphon.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Distributions

# Create continuous decorated graphon
f = DecoratedGraphon((x, y) -&gt; Normal(x * y, 0.1))

# Discretize into 10-block model
dsbm = empirical_graphon(f, 10)</code></pre><p><strong>See Also</strong></p><ul><li><a href="#Graphons.DecoratedGraphon"><code>DecoratedGraphon</code></a>: Continuous decorated graphon</li><li><a href="#Graphons.DecoratedSBM"><code>DecoratedSBM</code></a>: Block model with distributions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SDS-EPFL/Graphons.jl/blob/041c7921853d8de97ef275a7457e7e83dacba9d7/src/decorated_graphon.jl#L133-L160">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Graphons.AbstractGraphon"><code>Graphons.AbstractGraphon</code></a></li><li><a href="#Graphons.DecoratedGraphon"><code>Graphons.DecoratedGraphon</code></a></li><li><a href="#Graphons.DecoratedSBM"><code>Graphons.DecoratedSBM</code></a></li><li><a href="#Graphons.SBM"><code>Graphons.SBM</code></a></li><li><a href="#Graphons.SimpleContinuousGraphon"><code>Graphons.SimpleContinuousGraphon</code></a></li><li><a href="#Graphons.SimpleGraphon"><code>Graphons.SimpleGraphon</code></a></li><li><a href="#Graphons.WeightedGraphon"><code>Graphons.WeightedGraphon</code></a></li><li><a href="#Base.rand-Tuple{AbstractRNG, Graphons.AbstractGraphon, Int64}"><code>Base.rand</code></a></li><li><a href="../graphs_type/#Graphons._rand!"><code>Graphons._rand!</code></a></li><li><a href="#Graphons.empirical_graphon"><code>Graphons.empirical_graphon</code></a></li><li><a href="#Graphons.sample_graph"><code>Graphons.sample_graph</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../tutorials/">Tutorials »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 15 October 2025 09:59">Wednesday 15 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
