var documenterSearchIndex = {"docs":
[{"location":"graphs_type/#Graph-Types","page":"Graph representation","title":"Graph Types","text":"","category":"section"},{"location":"graphs_type/","page":"Graph representation","title":"Graph representation","text":"When creating Graphon objects, we can specify the type of graph to be sampled. By default, the sampled graphs are dense matrices. However, we can specify SparseMatrixCSC to obtain sparse graphs (should be supported by default), but other types are also possible.","category":"page"},{"location":"graphs_type/","page":"Graph representation","title":"Graph representation","text":"info: Work in Progress\nThis section is a work in progress. More graph types will be added in the future.","category":"page"},{"location":"graphs_type/#Design-Philosophy","page":"Graph representation","title":"Design Philosophy","text":"","category":"section"},{"location":"graphs_type/","page":"Graph representation","title":"Graph representation","text":"One of the main difficulties is that we cannot know what value is used to represent a non-edge in a decorated graph type. For example, for a simple graph encoded in a BitMatrix, a non-edge is represented by false. But for a weighted graph encoded in a Matrix{Float64}, there is no necessarily a default value for a non-edge. It could be 0.0, NaN, or any other value.","category":"page"},{"location":"graphs_type/","page":"Graph representation","title":"Graph representation","text":"To circumvent this issue, we have decided to let the user define how to create an empty graph of a given type if the default is not suitable. This means that the function to randomly sample a graph with preallocated memory now expects that the input graph is empty and of the right size.","category":"page"},{"location":"graphs_type/","page":"Graph representation","title":"Graph representation","text":"Graphons._rand!","category":"page"},{"location":"graphs_type/#Graphons._rand!","page":"Graph representation","title":"Graphons._rand!","text":"_rand!(rng::AbstractRNG, f::AbstractGraphon{T,M}, A::M, ξs)\n\nGenerates a random graph according to the graphon `f` and the latent positions `ξs`.\nThe generated graph is stored in `A`.\n\nwarning: Warning\nThis function expects that A is an empty graph of the right size and type. It does not try to clean it up before filling it. See make_empty_graph for more details.\n\n\n\n\n\n","category":"function"},{"location":"graphs_type/#Custom-Graph-Types","page":"Graph representation","title":"Custom Graph Types","text":"","category":"section"},{"location":"graphs_type/","page":"Graph representation","title":"Graph representation","text":"To sample with your own graph type, you need to redefine the function make_empty_graph(::Type{M}, n), such that it returns an empty graph of type M with n nodes and no edges.","category":"page"},{"location":"graphs_type/","page":"Graph representation","title":"Graph representation","text":"info: Design Choice\nSince for decorated graphs it is sometimes hard to know in advance what will be the default representation of a non-edge, we have left that choice to the user via the make_empty_graph function.","category":"page"},{"location":"graphs_type/","page":"Graph representation","title":"Graph representation","text":"An example of a custom graph type is provided in ext/SuiteSparseGraphBLAS.jl, which uses the SuiteSparseGraphBLAS package to create large sparse graphs efficiently.","category":"page"},{"location":"graphs_type/","page":"Graph representation","title":"Graph representation","text":"function make_empty_graph(::Type{GB}, n) where {GB<:GBMatrix}\n    return GB(n, n)\nend","category":"page"},{"location":"graphs_type/","page":"Graph representation","title":"Graph representation","text":"This allows us to create a Graphon object that will sample graphs of type GBMatrix:","category":"page"},{"location":"graphs_type/","page":"Graph representation","title":"Graph representation","text":"using SuiteSparseGraphBLAS\nf_sparseBLAS = SimpleContinuousGraphon((x,y)-> 0.1, GBMatrix{Bool})\nA = rand(f_sparseBLAS, 41)","category":"page"},{"location":"internal/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"internal/","page":"Index","title":"Index","text":"Modules = [Graphons]","category":"page"},{"location":"internal/#Graphons.AbstractGraphon","page":"Index","title":"Graphons.AbstractGraphon","text":"AbstractGraphon{T,M}\n\nT is the edge type:\n\nBool for a simple graph\n<:Real for a weighted graph\n<:AbstractVector{Bool} for a multiplex network\n...\n\nM is the type of the representation of the sampled graph from the graphon, e.g. a simple graph with boolean edges can be represented by     - a dense matrix of Bool -> M = Matrix{Bool}     - a sparse matrix of Bool -> M = SparseMatrixCSC{Bool,Int}     - an adjacency list -> M = Vector{Vector{Int}}\n\nfor now we assume that M is such that T <: eltype(M) and that it can be created with     make_empty_graph(M, n) which creates an empty graph of size n x n\n\n\n\n\n\n","category":"type"},{"location":"internal/#Base.rand-Union{Tuple{M}, Tuple{T}, Tuple{Random.AbstractRNG, Graphons.AbstractGraphon{T, M}, Int64}} where {T, M}","page":"Index","title":"Base.rand","text":"rand(rng::AbstractRNG, f::AbstractGraphon{T,M}, n::Int) where {T,M}\n\nGenerates a random graph according to the graphon `f` with `n` nodes.\nThe latent positions are drawn uniformly at random in [0,1].\n\nThe generated graph is of type `M` and has edge type `T`.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Graphons._rand!-Tuple{Random.AbstractRNG, Graphons.AbstractGraphon, Any, Any}","page":"Index","title":"Graphons._rand!","text":"_rand!(rng::AbstractRNG, f::AbstractGraphon{T,M}, A::M, ξs)\n\nGenerates a random graph according to the graphon `f` and the latent positions `ξs`.\nThe generated graph is stored in `A`.\n\nwarning: Warning\nThis function expects that A is an empty graph of the right size and type. It does not try to clean it up before filling it. See make_empty_graph for more details.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Graphons.sample_graph-Tuple{Random.AbstractRNG, Graphons.AbstractGraphon, Int64}","page":"Index","title":"Graphons.sample_graph","text":"sample_graph(rng::AbstractRNG, f::AbstractGraphon, n::Int)\n\nGenerates a random graph according to the graphon `f` with `n` nodes.\nThe latent positions are drawn uniformly at random in [0,1].\n\nThe generated graph is of type `M` and has edge type `T`.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"EditURL = \"../../literate/tutorials/01_simple_graphon.jl\"","category":"page"},{"location":"tutorials/01_simple_graphon/#A-Simple-Graphon-Introduction","page":"First steps","title":"A Simple Graphon Introduction","text":"","category":"section"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"This tutorial introduces the concept of a graphon, demonstrates how to sample a graph from one using Graphon.jl.","category":"page"},{"location":"tutorials/01_simple_graphon/#What-is-a-Graphon?","page":"First steps","title":"What is a Graphon?","text":"","category":"section"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"A graphon (or graph function) is a symmetric, measurable function","category":"page"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"W 0 1^2 to 0 1","category":"page"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"A graph with n nodes is then generated in the following manner:  For each node, i a latent variable xi_i sim U01 is drawn independently of the others","category":"page"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"It serves as a generative model for random graphs. Think of it as a continuous and more general version of a stochastic block model.","category":"page"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"In simple terms, each node i in a graph is assigned a latent (unobserved) position ξ_i in 0 1. The probability of an edge existing between two nodes i and j is then given by the graphon function evaluated at their latent positions:","category":"page"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"PA_ij = 1 mid xi_ixi_j = W(xi_ixi_j)","category":"page"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"This is an example of a simple graphon, which is used to generate simple binary undirected graphs. In subsequent tutorials, we will show that we can generalise this idea to much more general kind of graphs (weighted, signed, multiplex...).","category":"page"},{"location":"tutorials/01_simple_graphon/#Using-Graphon.jl-to-deal-with-Graphon","page":"First steps","title":"Using Graphon.jl to deal with Graphon","text":"","category":"section"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"We will be interested in a common graphon encountered in the litterature: W(xy)=x*y. This graphon is a Graphon.","category":"page"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"using Graphons\n\nfunction W(x, y)\n    return x * y\nend\n\nf = SimpleContinuousGraphon(W);\nnothing #hide","category":"page"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"We can also easily request a coarser version of the graphon, in the form of a stochastic block model with k blocks. This is done using the empirical_graphon function:","category":"page"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"step_graphon = empirical_graphon(f, 10);\nnothing #hide","category":"page"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"We can visualize this graphon using the any backend available in Makie.jl package. Here we will use CairoMakie.jl:","category":"page"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"using CairoMakie\n\nfig = Figure(size=(800, 380))\nax = Axis(fig[1, 1], aspect=1)\nax2 = Axis(fig[1, 2], aspect=1)\nxlims!(ax, 0, 1)# hide\nylims!(ax, 0, 1) # hide\nxlims!(ax2, 0, 1) # hide\nylims!(ax2, 0, 1) # hide\nhm = heatmap!(ax, f, colormap=:binary, colorrange=(0, 1))\nhm2 = heatmap!(ax2, step_graphon, colormap=:binary, colorrange=(0, 1))\nColorbar(fig[1, 3], hm)\nfig","category":"page"},{"location":"tutorials/01_simple_graphon/#Sampling-Graphs-from-a-Graphon","page":"First steps","title":"Sampling Graphs from a Graphon","text":"","category":"section"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"now that we have defined our graphon, we can sample graphs of different sizes with it:","category":"page"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"using Random\nA_medium = rand(f, 11)","category":"page"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"The above call will generate 10 random latent variables, and then sample the graph according to these random latents. In some settings we might be interested in knowing the latents for each of the nodes (e.g. for simulations). This is also possible easily:","category":"page"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"ξs = 0:0.1:1\nA_ordered = sample_graph(f, ξs)","category":"page"},{"location":"tutorials/01_simple_graphon/#Specifying-the-type-of-the-sampled-graph","page":"First steps","title":"Specifying the type of the sampled graph","text":"","category":"section"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"using SparseArrays\nM = SparseMatrixCSC{Bool,Int}\nf_sparse = SimpleContinuousGraphon(W, M)\nrand(f_sparse, 41)","category":"page"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"and we can see the impact of ordering the latents","category":"page"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"sample_graph(f_sparse, 0:0.025:1)","category":"page"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"","category":"page"},{"location":"tutorials/01_simple_graphon/","page":"First steps","title":"First steps","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"EditURL = \"../../literate/tutorials/02_multiplex_networks.jl\"","category":"page"},{"location":"tutorials/02_multiplex_networks/#Multiplex-networks-as-finitely-decorated-graphons-(2-layers)","page":"Multiplex networks","title":"Multiplex networks as finitely-decorated graphons (2 layers)","text":"","category":"section"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"This tutorial shows how a 2-layer multiplex network can be expressed as a finitely-decorated graphon with four categories K = {0,1,2,3} corresponding to:","category":"page"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"0 = no edge on either layer (00)\n1 = edge on layer 1 only (10)\n2 = edge on layer 2 only (01)\n3 = edge on both layers (11)","category":"page"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"We'll","category":"page"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"define a smooth decorated graphon W(x,y) returning a 4-probability vector over these categories,\nsample a multiplex network with two binary layers,\nvisualise marginals and cross-layer correlation induced by W.","category":"page"},{"location":"tutorials/02_multiplex_networks/#Setup","page":"Multiplex networks","title":"Setup","text":"","category":"section"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"using Random\nusing Distributions\nusing StaticArrays\nusing SparseArrays\nusing Graphons\nusing CairoMakie","category":"page"},{"location":"tutorials/02_multiplex_networks/#A-4-category-decorated-graphon-for-a-2-layer-multiplex","page":"Multiplex networks","title":"A 4-category decorated graphon for a 2-layer multiplex","text":"","category":"section"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"We define a function W = (w^00w^10w^01w^11) that returns  a distribution on K = {0,1,2,3}","category":"page"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"with mathbbP(K = k  X = x Y = y) = w^(k)(xy)","category":"page"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"function W(x, y)\n    ps = zeros(4)\n    ps[2] = sqrt(abs(x - y)) / 2\n    ps[3] = abs(sin(2π * x) * sin(2π * y)) / 2\n    ps[4] = min(x, y) / 4\n    ps[1] = (1 - sum(ps[2:4]))\n    return DiscreteNonParametric(0:3, SVector{4}(ps))\nend\n\ng = DecoratedGraphon(W);\nnothing #hide","category":"page"},{"location":"tutorials/02_multiplex_networks/#Visualising-the-four-category-probabilities","page":"Multiplex networks","title":"Visualising the four category probabilities","text":"","category":"section"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"We plot the four surfaces w^(ℓ)(xy) for ℓ ∈ {0,1,2,3}.","category":"page"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"fig = Figure(size=(350, 300)) # hide\nax1 = Axis(fig[1, 1], title=\"p00(x,y)\", aspect=1) # hide\nax2 = Axis(fig[1, 2], title=\"p10(x,y)\", aspect=1) # hide\nax3 = Axis(fig[2, 1], title=\"p01(x,y)\", aspect=1) # hide\nax4 = Axis(fig[2, 2], title=\"p11(x,y)\", aspect=1) # hide\nxlims!.([ax1, ax2, ax3, ax4], 0, 1) # hide\nylims!.([ax1, ax2, ax3, ax4], 0, 1) # hide\nhidexdecorations!.([ax1, ax2, ax3, ax4]) # hide\nhideydecorations!.([ax1, ax2, ax3, ax4]) # hide\nheatmap!(ax1, g, 1, colormap=:binary, colorrange=(0, 1)) # hide\nheatmap!(ax2, g, 2, colormap=:binary, colorrange=(0, 1)) # hide\nheatmap!(ax3, g, 3, colormap=:binary, colorrange=(0, 1)) # hide\nheatmap!(ax4, g, 4, colormap=:binary, colorrange=(0, 1)) # hide\nColorbar(fig[:, 3], colormap=:binary, colorrange=(0, 1)) # hide\nresize_to_layout!(fig)# hide\nfig# hide","category":"page"},{"location":"tutorials/02_multiplex_networks/#Sampling-a-multiplex-network-from-W","page":"Multiplex networks","title":"Sampling a multiplex network from W","text":"","category":"section"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"Given W, we can sample an adjacency category for each unordered pair (i,j) and then split categories into two binary adjacency matrices A1 and A2.","category":"page"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"n = 300\nRandom.seed!(42)\nA = sample_graph(g, n);\nnothing #hide","category":"page"},{"location":"tutorials/02_multiplex_networks/#Visualising-the-categories","page":"Multiplex networks","title":"Visualising the categories","text":"","category":"section"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"fig = Figure(size=(300, 300)) #hide\nax1 = Axis(fig[1, 1], aspect=1) # hide\nax2 = Axis(fig[1, 2], aspect=1) # hide\nax3 = Axis(fig[2, 1], aspect=1) # hide\nax4 = Axis(fig[2, 2], aspect=1) # hide\nhidedecorations!.([ax1, ax2, ax3, ax4]) # hide\nA_inter = zeros(Bool, n, n) # hide\nfor (c, ax) in zip(0:3, (ax1, ax2, ax3, ax4)) # hide\n    indices = findall(x -> x == c, A)  # indices with category c # hide\n    A_inter .= false # hide\n    A_inter[indices] .= true # hide\n    heatmap!(ax, A_inter, colormap=:binary, colorrange=(0, 1)) # hide\nend # hide\nresize_to_layout!(fig) # hide\nfig # hide","category":"page"},{"location":"tutorials/02_multiplex_networks/#Visualising-the-sampled-layers","page":"Multiplex networks","title":"Visualising the sampled layers","text":"","category":"section"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"indices_layer1 = findall(x -> x in (1, 3), A)  # hide\nindices_layer2 = findall(x -> x in (2, 3), A)  # hide\n\nA1 = zeros(Bool, n, n) # hide\nA2 = zeros(Bool, n, n) # hide\nA1[indices_layer1] .= true # hide\nA2[indices_layer2] .= true # hide\n\n\n\nfig = Figure(size=(300, 200)) # hide\nax1 = Axis(fig[1, 1], title=\"Layer 1\", aspect=1) # hide\nax2 = Axis(fig[1, 2], title=\"Layer 2\", aspect=1) # hide\nhidedecorations!.([ax1, ax2]) # hide\nheatmap!(ax1, A1, colormap=:binary, colorrange=(0, 1)) # hide\nheatmap!(ax2, A2, colormap=:binary, colorrange=(0, 1)) # hide\nresize_to_layout!(fig) # hide\nfig # hide","category":"page"},{"location":"tutorials/02_multiplex_networks/#From-categories-to-marginals-and-correlation","page":"Multiplex networks","title":"From categories to marginals and correlation","text":"","category":"section"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"For the two Bernoulli layers, we can estimate, for each (i,j), the model marginals and correlation induced by W. In practice we only observe one draw, but for visualisation we map (xy)rightarrow (p_1p_2corr) over a grid.","category":"page"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"using MVBernoulli\n\nfunction w_mvbern(x, y)\n    MVBernoulli.from_tabulation([probs(W(x, y))...])\nend\n\ng_mvbern = DecoratedGraphon(w_mvbern);\n\nsbm = empirical_graphon(g_mvbern, 10);\n\nsbm_test = DecoratedSBM(sbm.θ, sbm.size)\n\n\nget_marginals(d, k) = marginals(d)[k]\nget_correlation(d) = correlation_matrix(d)[1, 2]\n\n\np1 = [get_marginals(g_mvbern(x, y), 1) for x in 0:0.01:1, y in 0:0.01:1]\np2 = [get_marginals(g_mvbern(x, y), 2) for x in 0:0.01:1, y in 0:0.01:1]\ncorr = [get_correlation(g_mvbern(x, y)) for x in 0:0.01:1, y in 0:0.01:1]\n\n#\n\nfig = Figure(size=(800, 350)) # hide\nax1 = Axis(fig[1, 1], title=\"p1(x,y)\", aspect=1) # hide\nax2 = Axis(fig[1, 2], title=\"p2(x,y)\", aspect=1) # hide\nax3 = Axis(fig[1, 3], title=\"corr(x,y)\", aspect=1) # hide\nhidexdecorations!.([ax1, ax2, ax3]) # hide\nhideydecorations!.([ax1, ax2, ax3]) # hide\nhm1 = heatmap!(ax1, p1, colormap=:binary, colorrange=(0, 1)) # hide\nheatmap!(ax2, p2, colormap=:binary, colorrange=(0, 1)) # hide\nhm3 = heatmap!(ax3, corr, colormap=:balance, colorrange=(-1, 1)) # hide\nColorbar(fig[2, 1:2], hm1, vertical=false, width=Relative(0.5)) # hide\nColorbar(fig[2, 3], hm3, vertical=false) # hide\nfig # hide","category":"page"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"","category":"page"},{"location":"tutorials/02_multiplex_networks/","page":"Multiplex networks","title":"Multiplex networks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Graphons","category":"page"},{"location":"#Graphon","page":"Home","title":"Graphon","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Graphons.","category":"page"}]
}
